$date
  Tue Nov 11 12:32:13 2025
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module tb_nbitmux2to1 $end
$var reg 1 ! i_sel $end
$var reg 4 " i_d0[3:0] $end
$var reg 4 # i_d1[3:0] $end
$var reg 4 $ o_q[3:0] $end
$scope module dut $end
$var reg 1 % i_sel $end
$var reg 4 & i_d0[3:0] $end
$var reg 4 ' i_d1[3:0] $end
$var reg 4 ( o_q[3:0] $end
$scope module gen_mux(0) $end
$scope module mux_i $end
$var reg 1 ) s $end
$var reg 1 * x0 $end
$var reg 1 + x1 $end
$var reg 1 , y $end
$var reg 1 - not_s $end
$var reg 1 . selx0 $end
$var reg 1 / selx1 $end
$upscope $end
$upscope $end
$scope module gen_mux(1) $end
$scope module mux_i $end
$var reg 1 0 s $end
$var reg 1 1 x0 $end
$var reg 1 2 x1 $end
$var reg 1 3 y $end
$var reg 1 4 not_s $end
$var reg 1 5 selx0 $end
$var reg 1 6 selx1 $end
$upscope $end
$upscope $end
$scope module gen_mux(2) $end
$scope module mux_i $end
$var reg 1 7 s $end
$var reg 1 8 x0 $end
$var reg 1 9 x1 $end
$var reg 1 : y $end
$var reg 1 ; not_s $end
$var reg 1 < selx0 $end
$var reg 1 = selx1 $end
$upscope $end
$upscope $end
$scope module gen_mux(3) $end
$scope module mux_i $end
$var reg 1 > s $end
$var reg 1 ? x0 $end
$var reg 1 @ x1 $end
$var reg 1 A y $end
$var reg 1 B not_s $end
$var reg 1 C selx0 $end
$var reg 1 D selx1 $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
0!
b1010 "
b0101 #
b1010 $
0%
b1010 &
b0101 '
b1010 (
0)
0*
1+
0,
1-
0.
0/
00
11
02
13
14
15
06
07
08
19
0:
1;
0<
0=
0>
1?
0@
1A
1B
1C
0D
#20000000
1!
b0101 $
1%
b0101 (
1)
1,
0-
1/
10
03
04
05
17
1:
0;
1=
1>
0A
0B
0C
#40000000
0!
b1111 "
b0000 #
b1111 $
0%
b1111 &
b0000 '
b1111 (
0)
1*
0+
1,
1-
1.
0/
00
13
14
15
07
18
09
1:
1;
1<
0=
0>
1A
1B
1C
#60000000
1!
b0000 $
1%
b0000 (
1)
0,
0-
0.
10
03
04
05
17
0:
0;
0<
1>
0A
0B
0C
#80000000
